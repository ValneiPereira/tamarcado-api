# Docker Compose for Production - EC2 t3.micro (AWS Free Tier)
# API only - PostgreSQL runs on RDS (free tier)
#
# Usage:
#   cp .env.prod.example .env.prod
#   docker compose -f docker-compose.prod.yml --env-file .env.prod up -d

services:
  api:
    build:
      context: .
      dockerfile: Dockerfile
    image: tamarcado-api:latest
    container_name: tamarcado-api
    restart: unless-stopped
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      # Database (AWS RDS Free Tier)
      - DATABASE_HOST=${DATABASE_HOST:?DATABASE_HOST is required}
      - DATABASE_PORT=${DATABASE_PORT:-5432}
      - DATABASE_NAME=${DATABASE_NAME:-tamarcado}
      - DATABASE_USERNAME=${DATABASE_USERNAME:?DATABASE_USERNAME is required}
      - DATABASE_PASSWORD=${DATABASE_PASSWORD:?DATABASE_PASSWORD is required}
      - DATABASE_POOL_SIZE=5
      # Redis (Upstash - free)
      - REDIS_URL=${REDIS_URL:-}
      # JWT
      - JWT_SECRET=${JWT_SECRET:?JWT_SECRET is required}
      # CORS
      - CORS_ALLOWED_ORIGINS=${CORS_ALLOWED_ORIGINS:-*}
      # JVM Memory - optimized for t3.micro (1GB RAM, only API running)
      - JAVA_OPTS=-XX:MaxRAMPercentage=70.0 -XX:InitialRAMPercentage=50.0 -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:+UseStringDeduplication
    deploy:
      resources:
        limits:
          memory: 700M
        reservations:
          memory: 400M
    healthcheck:
      test: ["CMD-SHELL", "curl -sf http://localhost:8080/api/v1/actuator/health || exit 1"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 90s
